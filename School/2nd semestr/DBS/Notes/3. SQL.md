Prezentace: [[hand-les04-sql-select-1.pdf]], [[hand-les06-sql-select-2.pdf]] a cast z: [[hand-les05-transformace.pdf]]

### Poznamky
- rikame co ma byt vysledek - ne, jak to ziskat
- non-case sensitive
- ZASADNI rozdil mezi `'` a `"`
- hodne standardizaci (1986, **1992** - SQL 2, 1999, 2003, 2005, 2008, 2011,...)
	- nejvetsi odchylky v datovych typech
	- postupne se na sebe nabaluji (OO, XML,...)

- integritni omezeni (IO)
	- sloupce: NOT NULL, DEFAULT, UNIQUE (alternativni klic), PRIMARY KEY, REFERENCES (cizy klic), CHECK
	- tabulky: stejne jako IO sloupce
	- je vhodne si IO pojmenovat
	- ```
	create table items {
		order_id integer,
		item_id integer,
		amount integer,
		constraint items_pk primary key (order_id, item_id),
		constraint items_pk forein_key (order_id) references orders
			on delete cascade
			on update cascade
		};
	- PRIKLAD: integritni omezeni pro tvoreni tabulky
		- order_id a item_id jsou primarni klice
			- primarni klice jsou unikatni a not NULL!
		- order_id je forein_key (relacni klic - vytvari relaci) a zavislosti se na delete a update taky oddelaji
- SQL komentar `--`
- datove typy
	- numericke (Int), textove (Char, Character), datum a cas, NULL, ...
- prechod z relacni algebry do SQL je vice ukazany na slidech
	- ![[Pasted image 20230215173945.png]]
	- ![[Pasted image 20230215174055.png]]

#### Navrh ukazkove databaze
![[Pasted image 20230215162931.png]]
#### Jazyk pro dotazovani se na data (DQL - Data Query Language)
- SELECT
	- `SELECT co FROM odkud [WHERE podminka] [ORDER BY razeni]`
		- `co` -> {DISTINCT | <u>ALL</u> }  * | {nazev_sloupce \[, nazev_sloupce\]...}
			- DISTINCT se vztahuje na celou SELECT klauzuli
	- porovnavaci operatory: `=, !=, <, >, <=, >=, BETWEEN, IN, LIKE, EXISTS`
		- s WHERE muzeme pouzit i `AND, OR, NOT`
			- WHERE se vyhodnocuje jako T/F
		- `LIKE` - je v seznamu hodnot
		- `EXISTS` - je splnen poddotaz
	- spojeni s JOIN
		- `misto1 [{LEFT | RIGHT | FULL} [OUTER]] JOIN misto2 ON (podminka)`	
		- `misto1 [{LEFT | RIGHT | FULL} [OUTER]] JOIN misto2 USING (seznam_sloupcu)`
		- `misto1 [{LEFT | RIGHT | FULL} [OUTER]] NATURAL JOIN misto2`
		- `misto1 CROSS JOIN misto2`
			- kartezsky soucin
			- `misto1 , misto2`
	- kvalifikace, aliasy
		- `SELECT Predstaveni.nazev_k, Filmy.* FROM Filmy F JOIN Predstaveni P ON (F.nazev_f = P.nazev_f) ORDER BY P.nazev_k;`
	- spojeni tabulky samo se sebou
		- `SELECT soused1.rod_c AS prvni, soused2.rod_c AS druhy FROM zakaznici soused1 JOIN zakaznici soused2 USING (adresa) WHERE soused1.rod_c < soused2.rod_c;`
			- najdi dvojici zakazniku kteri maji stejnou adresu
	- agregacni funkce
		- relacni algebra to uz neumi
		- `COUNT` - bere mnozinu n-tic vyhazuje jednu hodnotu
			- pocet prvku v mnozine
			- `SELECT COUNT(*) FROM filmy WHERE rok BETWEEN 1938 AND 1940;`
			- kolik unikatnich hodnot: `SELECT COUNT (DISTINCT *) FROM rezervace`
		- `AVG` - prumer
			- `SELECT AVG(cena) FROM vypujcky` - prumerna cena vypujcky (bez ceny NULL)
		- `SUM`, `MIN`, `MAX`,...
	- napr: 
		- `SELECT reziser, rok FROM filmy;` - muze obsahovat duplicity (zalezi na zdroji)
		- `SELECT reziset, rok FROM filmy ORDER BY reziser, rok;` - razi se podle rezisera, pak roku (A->Z, 1->...)
			-  `SELECT reziset, rok FROM filmy ORDER BY reziser ASC, rok DESC;` - reziser (A->Z), rok (...->1)
		- `SELECT DISTINCT reziser, rok FROM filmy;` - oddelaji se duplicity z prvniho prikladu
		- `SELECT * FROM filmy WHERE rok < 1940` - vsechny filmy pred 1940
		- `SELECT * FROM filmy WHERE rok>=1938 AND rok<=1940;`
			- da se napsat jako:  `SELECT * FROM filmy WHERE rok BETWEEN 1938 AND 1940;`
				- nebo treba `NOT BETWEEN`, haha spousta moznosti
		- `SELECT DISTINCT reziser FROM filmy JOIN rezervace ON (filmy.nazev_f=rezervace.nazev_f);`
			- alternativa1: `SELECT DISTINCT reziser FROM filmy JOIN rezervace USING (nazev_f);` 
			- alternativa2: `SELECT DISTINCT reziser FROM filmy NATURAL JOIN rezervace;`
			- alternativa3: `SELECT DISTINCT reziser FROM filmy, rezervace WHERE filmy.nazev_f=rezervace.nazev_f;`
		- 
#### Jazyk pro definici dat (DDL - Data Definition Language)
- CREATE TABLE
	- `CREATE TABLE tabulka ( sloupec datovy_typ [ io_sloupce, [ io_sloupce ]], ... );`
- ALTER TABLE
	- `ADD sloupec, DROP sloupec, ALTER sloupec, ADD CONSTRAINT io, DROP CONSTRAINT io`
- DROP TABLE
	- `DROP TABLE tabulka [CASCADE];`
	- pokud se pouzije bez CASCADE a na tabulce je zavisla jina tabulka, tak vyhodi chybu -> musi se pustit s CASCADE
- TRUNCATE
#### Jazyk pro manipulaci dat (DML - Data Manipulation Language)
- INSERT
- UPDATE
- DELETE
- CALL
- EXPLAIN CALL
- LOCK
#### Jazyk pro prirazeni pristupovych prav (DCL - Data Control Language)
- GRANT
- REVOKE
#### Jazyk pro rizeni transakci (TCL - Transaction Control Language)
- COMMIT
- SAVEPOINT
- ROLLBACK
- SET transaction
- SET Contstraint