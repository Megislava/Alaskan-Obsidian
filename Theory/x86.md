## x86
- data representation:
	-   least significant bit (LSB) - the one on far right
	-   most significant bit (MSB) - the one far on left
	-   little-endian - LSB is stored first
	-   big-endian - MSB is sroted first
-   x86 is a little-endian

### Registers:
1. GPRs (general purpose registers)
	- eax - accumulator register - to accumulate results of arithmatic operations
	- ebx - the base register - to store the base of an address
	- ecx - the counter register - to count, usually used in loops
	- edx - the data register - store and work w/ data 
	- esi - source index register - to store the index into a source array
	- edi - destination index register - to store the index of a destination array 
	- ebp - base pointer - stores the address of the case of the stack frame
	- esp - stack pointer - addresses the top of the stack frame
2. SPRs (special purpose registers)
	- eip - instruction pointer - stored s address of the next instruction to execute
	- eflags - stored the flags about system state and info about the resilts of previously executed instructions
	- cannot be access directly - `mov eip,1` <- does not assemble
- registers ending with 'x' can be access in parts:
	- *eax* ~ 32-bit register; *ax* ~ lower 16-bit of erx; *ah* ~ higher/top 8-bits of rx; *al* ~ lower 8-bits of rx 
	[[17.PNG]]
- in x86_64 (64-bit) the register name starts with 'r' (*eax*)

### Accessing memory
- with `[]` notation, eg. `[0x231435]` access the value stored at memory address 0x231435; `[eax]` access the value stored at the memory pointed to by eax
- different sizes of memory can be accessed
	- `byte [100]` (single byte on address 100), `word[ebx]` (word ~ 2 bytes pointed to by ebx), `dword[ax]` (doubleword ~ 4bytes pointed to by ax)
- direct and indirect addressing
	- direct - directly address some constant value address - by number of the address, offset or label; like global variable
	- indirect - uses a register to indicate the address, like pointers, the address "name" is not know before compilation, only 16- and 32-bit GPR can be used for indirect addressing (no 8-bit/SPR)
- base + displacement addressing
	- used often for array work
	- uses register and an absolute displacement
	- like local variable
	- eg. `[ ebx + 0x100 ]`
- indexed addressing
	- uses an index register, scale factor and a displacement for an address
	- for arrays, structures etc where you know the base and the max size/offset
	- the index must be 1, 2, 4, or 8
	- eg. `[ eax * 2 + 0x100]`
- based-indexed addressing
	- uses a base register, index register, scale factor and a displacement for the address
	- like structure
	- the index must be 1, 2, 4, or 8
	- eg. `[ ebx + edi * 4 + 0x1000 ]`
- [[18.PNG]]

### Instructions
- generally x86 instruction can access multiple of registers at once but:
	- only one memory location at once (`[0x12436666]`)
1. Arithmetic
	1. add, sub
		- addition, subtration
		- destication can be register/memory
		- value: register/memory/immediate
		- operands must have the same size (`add eax, bx` is invalid)
		- `add destination, value`
		- `sub destination, value`
		- `add eax, ebx` - add ebx to eax and store in eax
		- `sub ecx, [ 100 ]` - subtract the 32-bit (ecx is 32-bit) value at address `[ 100 ]` from ecx and store in ecx
		- `add dword [ edx ], 100` - add 100 to 32-bit value pointed to by edx and store there, 
	3. mul
		- multiply eax by operand, stores the result in edx:eax
		- `mul [ memory ]` / `mul register`
		- ALWAYS uses eax register as source
		- ALWAYS stores as edx:eax
		- -> eax and edx are always modified 
		- `mul eax` - edx:eax = eax * eax (eax square)
		- `mul ebx` - edx:eax = eax * ebx
		- `mul dword [ 0x555 ]` - edx:eax = eax * (32-bit value at address 0x555)
		- `mul byte [ 0x123 ]` - edx:eax = eax * (8-bit value an address 0x123)
	4. div
		- divide edx:eax by operand, store quotient in eax and reminder in edx
		- `div [ memory ]` or `div register`
		- source and storage is alwaus same -> eax and edx are always modified
		- `div eax` - eax, edx = edx:eax / eax
		- `div ebx` - eax, edx = edx:eax / ebx
		- `div dword [ 0x555 ]` - eax, edx = edx:eax / (32-bit value at address 0x555)
		- `div byte [ 0x123 ]` - eax, edx = edx:eax / (8-bit value at address 0x123)
		- eg. calculate the remainder of 123/4:
			- `mov eax, 123` - load 123 to eax
			- `mov edx, 0` - clear the divident; DON'T FORGET THIS STEP
			- `mov ecx, 4` - we cannot directly divide by 4, it needs to be saved in memory
			- `div ecx` - edx:eax / ecx => quotient in eax, reminder in edx
	5. inc, dec
		- increment/decrement by 1
		- `inc eax` - increment the eax register by 1
		- `dec dx` - decrease dx register by 1
		- `inc word [ ecx ]` - increment the 16-bit value pointed to by ecx
		- `dec dword [ 0x11223344 ]` - decrease the 32-bit value at 0x11223344 by 1
2. Bit manipulation
	1. and, or, xor
		- `add/or/xor destination, source`
		- destination can be register/memory address
		- source can be destination/memory address/immediate
		- `or eax, 0xfffffffff` - set eax to all 1's
		- `and dword [ 0xdeadbeaf ], 0x1` - mask off low bit of 32-bit valut at 0xdeadbeaf
		- `xor ecx, eax` - ecx = ecx ^ eax; 
		- `xor eax, eax` - common way to clear a register
	2. not
		- binary not
		- `not register` / `not [ memory ]`
		- inverting the bits
	3. shr, shl
		- logical shift right/left
		- `shr register, immediate` / `shr [ memory ], immediate`
		- `shl register, immediate` / `shl [ memory ], immediate` 
		- shifts the bits in register/memory left or right by the immediate value
		- if there shift will create empty spots, those are filled with 0
	4. sar, sal
		- arithmetic shift right or left
		- `sar register, immediate`, `sar [ memory ], immediate`
		- `sal register, immediate`, `sal [ memory ], immediate`
		- shifts the bits in register/memory to right or left by the immediate value
		- extends the value on shigt right, extends by zero on left
3. Stack
	1. call
	2. return
	3. push
	4. pop
4. Data movement
	1. mov
		- moves (it's actually copy) data from one location to another
		- `mov destination, source`
		- [[19.PNG]]
5. Execution flow
	1. jmp
		- jump to line
		- `jmp $` - loop forever
	2. Conditional jumps
6. Comparison
	1. test
	2. cmp
7. Other
	1. lea
		- load effictive address
		- `lead destination, [ source ]`
		- computes the address of the source operand and places in the destination operand
		- similar to the & operand in C
		- often use for simple math
		- `lea eax, [ 100 ]` - computes the effective address of [ 100 ] (=100) and stores it in eax
		- `lea ecx, [ ebx ]` - computes the effective address of [ebx] (=ebx) and stores is in ecx
		- `lea eax, [ ebx + ecx + 5 ]` - computes the effective address of [ebx+ecx+5] and stores it in eax
		- variables are often stored at offsets from a register
		- eg.: `int i = 7 [100]; char j = 5 [200]; int k = i + j [300]`
			- traditionally: 
			```	mov dword [ 100 ], 7 	; set i
				mov byte [ 200 ], 5 	; set j	

				mov eax, [ 100 ]		; load i into eax
				xor ebx, ebx			; zero ebx
				mov bl, [ 200 ]			; load j into ebx

				add eax, ebx			; add ebx to eax, store in eax

				mod [ 300 ], eax		; save result to k
			```
		- eg2.: `int i = 7 [100]; char j = 5 [200]; int k = i * i + j * j [300]`		
			- traditionally: 
			``` mov dword [ 100 ], 7 	; set i
				mov byte [ 200 ], 5 	; set j	

				mov ecx, [ 100 ]		; load i into ecx
				xor ebx, ebx			; zero ebx
				mov bl, [ 200 ]			; load j into ebx

				mov eax, ecx			; copy ecx to eax (eax=ecx=i)
				mul ecx					; multiply ecx by eax, store in eax
				mov ecx, eax			; save result to ecx to free eax

				mov eax, ebx			; copy ebx to eax (eax=ebx=j)
				mul ebx					; multiply ebx by eax, store in eax

				add eax, ecx			; add ecx to eax, store in eax
				mod [ 300 ], eax		; save result to k
			```	
	
	1. nop
		- `nop` = not operation
		- does nothing
		- compiles to exactly one byte in machine code (0x90)
		- used for: timing, memory alignment, hazard prevention, branch delay slot, a placeholder, hacking (nop sleds), cracking (nop outs)

### Others
- common mistakes:
	- [[20.PNG]]
- building and linking
	- create file with `.asm` extenstion
	- assemble into an object file: `nasm -f elf XXX.ams`
	- link an object file: `ld -melf_i386 XXX.o -o XXX.out`
		- creates a XXX.out executable
		- `-melf_x386` - tells ld to link for x86 elf (linux executable format)
	- run the output: `./XXX.out`
	- sections and start 
	```section .text 	; section for code
		global _start	; exports start method
		_start:			; execution starts here

		; code here

		section .data	; section for data

		; variables here
	```
		
### Data representation
- labels
	- basically constant or immediate value that has a name
	- but not a variable
- constants
	- is defined with EQU directive -> `MAX_SIZE EQU 1000`
	- immutable
- global
	- flexible way to reserve space for global data
	- `Db` one byte; `Dw` one word (two bytes); `Dd` one  dword (four bytes); `Dq` one qword (eight bytes)
	- [[21.PNG]]
	- eg:	
	```	section .text 			; section for function
		mov dword [ i ], 1		; move 1 to 32-bit value  addresses as i

		section .data			; section for data
		i: dd 0 				; address i is one DWORD with initial value 0
	```		
- strings
	- typically used as a sequence of bytes in memory
	- `label: db "hello", 0`
	- has to be null terminated!!
- times
	- causes the instruction or prefix to repeated multiple times
	- `times 100 db 0` - creates 100 bytes, initialized w/ 0
	- `times 64 db 0x55` - creates a 64 bytes DWORD initialized with 0x55
	- `buffer: db 'hello, world'
		times 64-$+buffer db ' '` -> pad "hello world" to a length of 64
- $
	- shortcut for "address of the current line", temporary, moving label
	```	string: db "hello"		; label string is obe byte with value "hello"
		.l EQU $-string			; .length of string = current line - string
	```
	
### Input and output
- pins are divided to groups = ports -> controlling ports
- setting a value on the pins = writing to the port
- getting a walue from the pins = reading from the port
- a lot of ports: [[22.PNG]]
- `in register, port`
	- eg. `in al, 0x64` - get keyboard status
- `out port, register`
	- eg. `out 0x3c0, eax` - set a pixel
- we don't need to communicate separately w/ each port => GRAPHIC CARD

- `int 0x80`
	- Linux system call
	- int = interrupt
	- loading particular value into particular registers
		- `eax = 4` : writes data (1 for exit)
		- `ebx = 1` : to standart output
		- `ecx` = data address
		- `edx` = bytes to write
		- the order does not matter
- simple Hello World!:
```
global _start

section .text
_start:
	mov eax, 4				; write
	mov ebx, 1				; stdout
	mov ecx, msg			; the message
	mov edx, msg.len		; the length of the message
	int 0x80
	
	mov eax, 1				; exit the program
	mov ebx, 0
	int 0x80

section .data

msg: db "Hello, world!", 10
.len: equ & - msg			; how to compute .len
```

### Strings